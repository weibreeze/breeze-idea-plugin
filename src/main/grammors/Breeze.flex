package com.weibo.breeze.plugin.psi;

import com.intellij.lexer.FlexLexer;
import com.intellij.openapi.vcs.changes.ignore.psi.impl.IgnoreNegationImpl;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.TokenType;

import static com.intellij.psi.TokenType.BAD_CHARACTER;
import static com.intellij.psi.TokenType.WHITE_SPACE;
import static com.weibo.breeze.plugin.psi.BreezeTypes.*;

/**
*  this code is generated by Flex
*/
%%

%{
    protected int nextState;
%}

%implements FlexLexer
%class BreezeLexer
%unicode
%function advance
%type IElementType
%eof{  return;
%eof}

CRLF=\n | (\r\n?)
WHITE_SPACE=[\ \t]
//END_LINE = {WHITE_SPACE}*{EOL_COMMENT}?{CRLF}
END_LINE = {WHITE_SPACE}*{CRLF}
DIGIT = [0-9]
NON_ZERO_DIGIT = [1-9]
FIRST_CHAR = [_A-Za-z]
NORMAL_CHAR = {DIGIT} | {FIRST_CHAR}
TYPE_CHAR = {NORMAL_CHAR}|\.
NAME = {FIRST_CHAR}{NORMAL_CHAR}*
TYPE = {FIRST_CHAR}{TYPE_CHAR}*
INDEX = {NON_ZERO_DIGIT}{DIGIT}*
// TODO 单纯靠正则只能定位，但是无法解析。后续如果需要解析集合元素类型用于逻辑判断，这里再改成用状态机迭代解析array和map类型参数。
TYPE_ELEMENT_CHAR = {TYPE_CHAR}|[<>, ]

FIRST_CONFIG_CHAR=[^ \r\n\f\\;,(){}=] | "\\"{CRLF} | "\\".
CONFIG_CHAR=[^\r\n\f\\;,()=] | "\\"{CRLF} | "\\".
CONFIG_KEY = {FIRST_CHAR}({TYPE_CHAR} | -)*
CONFIG_VALUE = {FIRST_CONFIG_CHAR}{CONFIG_CHAR}*
EOL_COMMENT=("//")[^\r\n]*

%state ST_PACKAGE ST_OPTION ST_READ_OPTION_VALUE  ST_CONFIG
%state ST_MESSAGE ST_ENUM ST_READ_FIELD_TYPE ST_READ_FIELD_NAME ST_READ_FIELD_INDEX
%state ST_SERVICE ST_READ_METHOD ST_READ_PARAM_TYPE ST_READ_PARAM_NAME ST_READ_RETURN_TYPE

%%

<YYINITIAL> {
    {EOL_COMMENT}                           { return COMMENT; }
    // keywords
    "option"                                { nextState = YYINITIAL; yybegin(ST_OPTION); return OPTION_KEYWORD; }
    "message"                               { yybegin(ST_MESSAGE); return MESSAGE_KEYWORD; }
    "package"                               { yybegin(ST_PACKAGE); return PACKAGE_KEYWORD; }
    "service"                               { yybegin(ST_SERVICE); return SERVICE_KEYWORD; }
    "enum"                                  { yybegin(ST_ENUM); return ENUM_KEYWORD; }
    "config"                                { yybegin(ST_CONFIG); return CONFIG_KEYWORD; }
    {NAME}                                  { return UNKNOWN_WORD;}
}

<ST_PACKAGE> {
    {TYPE}                                  {return VALUE;}
    ";"                                     { yybegin(YYINITIAL); return SIGN_LINE_END;}
}

<ST_OPTION> {
    {CONFIG_KEY}                            {return KEY;}
    "="                                     {yybegin(ST_READ_OPTION_VALUE); return SEPARATOR;}
    "}"                                     {yybegin(YYINITIAL); return SIGN_SECTION_END;}
}

<ST_READ_OPTION_VALUE>{
    ","                                     {yybegin(ST_OPTION); return SIGN_COMMA;}
    ")"                                     { yybegin(nextState); return SIGN;}
    {CONFIG_VALUE}                          {return VALUE;}
    ";"                                     {if (nextState == YYINITIAL) { yybegin(YYINITIAL); return SIGN_LINE_END; } yybegin(ST_OPTION); return SIGN_LINE_END; }
}

<ST_MESSAGE>{
    {NAME}                                  {return NAME;}
    "("                                     {nextState = yystate(); yybegin(ST_OPTION);return SIGN;}
    "{"                                     {yybegin(ST_READ_FIELD_TYPE);return SIGN_SECTION_START;}
}

<ST_READ_FIELD_TYPE>{
//TODO 增加 array和map 关键词处理
    {TYPE}(<{TYPE_ELEMENT_CHAR}+>)?                                {nextState = yystate(); yybegin(ST_READ_FIELD_NAME);return TYPE;}
    "}"                                     {yybegin(YYINITIAL);return SIGN_SECTION_END;}
}

<ST_READ_FIELD_NAME>{
    {NAME}                                  {return PARAM_NAME;}
    "="                                     {yybegin(ST_READ_FIELD_INDEX); return SEPARATOR;}
    "}"                                     {yybegin(YYINITIAL);return SIGN_SECTION_END;}
}

<ST_READ_FIELD_INDEX>{
    {INDEX}                                 {return INDEX;}
    ";"                                     {if (nextState == ST_ENUM) { yybegin(ST_READ_FIELD_NAME); return SIGN_LINE_END; } yybegin(ST_READ_FIELD_TYPE); return SIGN_LINE_END; }
}

<ST_ENUM>{
    {NAME}                                  {return NAME;}
    "("                                     {nextState = yystate(); yybegin(ST_OPTION);return SIGN;}
    "{"                                     {nextState = yystate();yybegin(ST_READ_FIELD_NAME);return SIGN_SECTION_START;}
}


<ST_CONFIG>{
    {NAME}                                  {return NAME;}
    "{"                                     {nextState = yystate();yybegin(ST_OPTION); return SIGN_SECTION_START;}
}

<ST_SERVICE>{
    {NAME}                                  {return NAME;}
    "("                                     {nextState = yystate(); yybegin(ST_OPTION);return SIGN;}
    "{"                                     {yybegin(ST_READ_METHOD);return SIGN_SECTION_START;}
}

<ST_READ_METHOD>{
    {NAME}                                  {return NAME;}
    "("                                     {yybegin(ST_READ_PARAM_TYPE);return SIGN;}
    "}"                                     {yybegin(YYINITIAL);return SIGN_SECTION_END;}
}

<ST_READ_PARAM_TYPE>{
    {TYPE}(<{TYPE_ELEMENT_CHAR}+>)?                                  {yybegin(ST_READ_PARAM_NAME);return TYPE;}
    ")"                                     {yybegin(ST_READ_RETURN_TYPE);return SIGN;}
}

<ST_READ_PARAM_NAME>{
    {NAME}                                  {return PARAM_NAME;}
    ","                                     {yybegin(ST_READ_PARAM_TYPE);return SIGN_COMMA;}
    ")"                                     {yybegin(ST_READ_RETURN_TYPE);return SIGN;}
}

<ST_READ_RETURN_TYPE>{
    {TYPE}(<{TYPE_ELEMENT_CHAR}+>)?                                  {return TYPE;}
    ";"                                     {yybegin(ST_READ_METHOD);return SIGN_LINE_END;}
}

{EOL_COMMENT}                               { return COMMENT; }
{CRLF}| {WHITE_SPACE}+                      {return WHITE_SPACE;}
[^]                                         { return BAD_CHARACTER; }

